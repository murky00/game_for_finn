<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <!-- Viewport setting is CRITICAL for iPad: prevents zooming and auto-scaling -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>128x128 Cellular Automaton (iPad)</title>
    <style>
        body {
            background-color: #222;
            color: white;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            margin: 0;
            height: 100vh; /* Full screen height */
            overflow: hidden; /* Prevent body scroll */
            touch-action: none; /* Disable default browser gestures */
        }

        h1 { 
            font-size: 1.5rem; 
            margin: 10px 0; 
            text-align: center;
        }

        .controls {
            margin-bottom: 10px;
            background: #333;
            padding: 10px;
            border-radius: 12px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        /* Bigger buttons for fingers */
        button {
            padding: 12px 20px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 8px;
            /* Remove tap highlight color on iOS */
            -webkit-tap-highlight-color: transparent; 
        }
        button:active { transform: scale(0.95); }
        button.stop { background-color: #f44336; }
        button.clear { background-color: #555; }
        
        canvas {
            background-color: white;
            border: 2px solid #555;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            image-rendering: pixelated; 
            
            /* Responsive Sizing */
            width: 95vw;  /* 95% of viewport width */
            height: 95vw; /* Keep it square */
            max-width: 600px; /* But don't get too huge on desktop */
            max-height: 600px;
            
            /* Vital for iPad drawing */
            touch-action: none; 
        }

        .stats {
            margin-top: 10px;
            font-size: 12px;
            color: #aaa;
        }
    </style>
</head>
<body>

    <h1>Life 128x128</h1>

    <div class="controls">
        <button id="btnStart">Play</button>
        <button id="btnStop" class="stop">Pause</button>
        <button id="btnRandom">Rand</button>
        <button id="btnClear" class="clear">Clear</button>
    </div>

    <!-- Canvas internal resolution is 512, but CSS scales it visually -->
    <canvas id="gameCanvas" width="512" height="512"></canvas>
    
    <div class="stats">
        Gen: <span id="genCount">0</span>
    </div>

    <script>
        // --- CONFIGURATION ---
        const GRID_SIZE = 128;
        // Internal resolution (higher = sharper text/lines if we added them, 
        // but for pixels 512 is a good multiple of 128)
        const CANVAS_INTERNAL_SIZE = 512; 
        const CELL_PIXEL_SIZE = CANVAS_INTERNAL_SIZE / GRID_SIZE;
        const FPS = 30;

        // --- STATE ---
        let grid = createGrid();
        let isRunning = false;
        let generation = 0;
        let animationId = null;
        let lastFrameTime = 0;

        // --- DOM ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { alpha: false }); // Optimization
        const genDisplay = document.getElementById('genCount');

        // --- INIT ---
        randomizeGrid();
        draw();

        // --- CONTROLS ---
        document.getElementById('btnStart').addEventListener('click', () => {
            if (!isRunning) {
                isRunning = true;
                loop();
            }
        });

        document.getElementById('btnStop').addEventListener('click', () => {
            isRunning = false;
            cancelAnimationFrame(animationId);
        });

        document.getElementById('btnRandom').addEventListener('click', () => {
            randomizeGrid();
            generation = 0;
            draw();
        });

        document.getElementById('btnClear').addEventListener('click', () => {
            grid = createGrid();
            generation = 0;
            isRunning = false;
            draw();
        });

        // --- INTERACTION (TOUCH & MOUSE) ---
        
        // Helper to get position for both Touch and Mouse
        function getPointerPos(e) {
            const rect = canvas.getBoundingClientRect();
            // Scale factor between CSS size and Internal Canvas size
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;

            let clientX, clientY;

            if (e.touches && e.touches.length > 0) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }

            return {
                x: (clientX - rect.left) * scaleX,
                y: (clientY - rect.top) * scaleY
            };
        }

        function handleInput(e) {
            // Prevent scrolling on iPad when touching canvas
            if(e.cancelable) e.preventDefault(); 

            const pos = getPointerPos(e);
            const col = Math.floor(pos.x / CELL_PIXEL_SIZE);
            const row = Math.floor(pos.y / CELL_PIXEL_SIZE);

            if (col >= 0 && col < GRID_SIZE && row >= 0 && row < GRID_SIZE) {
                grid[col][row] = 1; 
                // Immediate draw feedback
                ctx.fillStyle = '#000000';
                ctx.fillRect(
                    col * CELL_PIXEL_SIZE, 
                    row * CELL_PIXEL_SIZE, 
                    CELL_PIXEL_SIZE, 
                    CELL_PIXEL_SIZE
                );
            }
        }

        // Mouse Events
        let isMouseDown = false;
        canvas.addEventListener('mousedown', (e) => { isMouseDown = true; handleInput(e); });
        canvas.addEventListener('mousemove', (e) => { if (isMouseDown) handleInput(e); });
        window.addEventListener('mouseup', () => isMouseDown = false);

        // Touch Events (iPad specific)
        canvas.addEventListener('touchstart', (e) => { isMouseDown = true; handleInput(e); }, {passive: false});
        canvas.addEventListener('touchmove', (e) => { if (isMouseDown) handleInput(e); }, {passive: false});
        canvas.addEventListener('touchend', () => isMouseDown = false);

        // --- GAME LOGIC ---

        function createGrid() {
            return new Array(GRID_SIZE).fill(null).map(() => new Array(GRID_SIZE).fill(0));
        }

        function randomizeGrid() {
            for (let x = 0; x < GRID_SIZE; x++) {
                for (let y = 0; y < GRID_SIZE; y++) {
                    grid[x][y] = Math.random() > 0.85 ? 1 : 0;
                }
            }
        }

        function loop(timestamp) {
            if (!isRunning) return;
            const deltaTime = timestamp - lastFrameTime;
            if (deltaTime >= 1000 / FPS) {
                update();
                draw();
                lastFrameTime = timestamp;
            }
            animationId = requestAnimationFrame(loop);
        }

        function update() {
            // Using a single buffer for simple state is faster, 
            // but for GoL we need a clean buffer for the next step.
            const nextGrid = new Array(GRID_SIZE);
            
            for (let x = 0; x < GRID_SIZE; x++) {
                nextGrid[x] = new Int8Array(GRID_SIZE); // Memory optimization
                for (let y = 0; y < GRID_SIZE; y++) {
                    const state = grid[x][y];
                    
                    // Optimized Neighbor Counter
                    let neighbors = 0;
                    for (let i = -1; i <= 1; i++) {
                        for (let j = -1; j <= 1; j++) {
                            if (i === 0 && j === 0) continue;
                            const col = (x + i + GRID_SIZE) & 127; // Fast modulo for 128
                            const row = (y + j + GRID_SIZE) & 127; // Fast modulo for 128
                            neighbors += grid[col][row];
                        }
                    }

                    if (state === 0 && neighbors === 3) {
                        nextGrid[x][y] = 1;
                    } else if (state === 1 && (neighbors < 2 || neighbors > 3)) {
                        nextGrid[x][y] = 0;
                    } else {
                        nextGrid[x][y] = state;
                    }
                }
            }
            grid = nextGrid;
            generation++;
            genDisplay.innerText = generation;
        }

        function draw() {
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(0, 0, CANVAS_INTERNAL_SIZE, CANVAS_INTERNAL_SIZE);
            ctx.fillStyle = '#000000';
            
            // Draw all black cells
            ctx.beginPath();
            for (let x = 0; x < GRID_SIZE; x++) {
                for (let y = 0; y < GRID_SIZE; y++) {
                    if (grid[x][y]) {
                        ctx.rect(
                            x * CELL_PIXEL_SIZE, 
                            y * CELL_PIXEL_SIZE, 
                            CELL_PIXEL_SIZE, 
                            CELL_PIXEL_SIZE
                        );
                    }
                }
            }
            ctx.fill();
        }
    </script>
</body>
</html>